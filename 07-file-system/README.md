# 파일시스템

리눅스에서는 저장 장치 안의 데이터에 접근 할 때 일반적으로 직접 저장 장치에 접근하지 않고 편의를 위해 파일시스템을 통해 접근한다.

컴퓨터 시스템에 파일시스템이 있는 것은 당연한 일처럼 여겨지지만, 파일시스템이 없는 세상을 상상해보며 **파일시스템의 필요성**에 대해 살펴보자.

저장 장치의 기능은 단순하게 말하면 '저장 장치 안에 지정된 주소에 대해 특정 사이즈의 데이터를 읽거나 쓰는 것'이다. 만약 파일시스템이 없다면 저장 장치에 쓰고 읽기 위해서는 다음과 같은 정보를 별도로 관리해야 한다.

![모든 데이터에 대해 보관한 주소, 사이즈를 관리할 필요가 있음](/images/07-file-system/7-2.png)  

이러한 복잡한 처리를 피하고자, 어디에 어느 정도의 데이터가 있는지, 어디가 빈 영역인지를 관리하는 방식이 파일시스템이다.

### 파일 시스템의 역할
파일 시스템은 사용자에 의미가 있는 하나의 데이터를 **이름, 위치, 사이즈** 등의 **보조 정보**를 추가하여 **파일**이라는 단위로 관리한다. 어느 장소에 어떤 파일을 배피할 지 등의 데이터 구조는 사양으로 미리 정하며, 커널 내부에서 파일시스템을 다루기 위한 처리가 사양을 바탕으로 데이터를 다루게 된다.

![단순한 파일시스템의 예](/images/07-file-system/7-3.png)  

사용자가(정확히는 사용자의 프로세스가) 파일 읽기 시스템 콜을 사용하여 파일 이름과 파일상의 오프셋 및 사이즈를 지정하면 파일시스템을 다루는 처리가 해당하는 데이터를 찾아서 사용자에게 전달한다.

![파일 이름, 파일상의 오프셋, 사이즈를 지정하면 해당하는 데이터를 읽을 수 있음](/images/07-file-system/7-4.png)  

### 리눅스의 파일 시스템
파일을 카테고리 별로 정리할 수 있도록 리눅스의 파일시스템에는 디렉터리(directory)라고 부르는 파일을 보관하는 특수한 파일이 존재한다. 이를 위해 리눅스의 파일시스템은 **트리 구조**로 되어 있다.

![트리 구조의 파일시스템](/images/07-file-system/7-5.png) 

### 파일시스템 콜(call)
리눅스가 다루는 파일시스템은 1개가 아니라 'ext4', 'XFS', 'Btrfs' 등 여러 개의 파일시스템을 다룰 수 있다. 각 파일시스템은 저장 장치의 데이터 구조 및 그것을 처리하기 위한 프로그램이 다르며, 다룰 수 있는 파일의 사이즈, 파일시스템의 사이즈, 개개의 처리(파일 작성, 삭제, 읽기, 쓰기 등)의 속도 등도 다르다.

하지만 **어떤 파일시스템이라도 사용자가 다음과 같은 시스템 콜을 호풀한다면 통일된 인터페이스로 접근이 가능하다**.

* 파일의 작성, 삭제: create(), unlink()
* 파일을 열기, 닫기: open(), close()
* 데이터 읽기: read()
* 데이터 쓰기: write()
* 파일 이동: lseek()
* 위에 언급한 것 이외의 파일 시스템에 의존적인 특수한 처리: ioctl()

위의 시스템 콜이 호출되면 다음과 같은 순서로 파일의 데이터가 읽어진다.

1. 커널 내의 모든 파일시스템 공통 처리가 동작하고 대상 파일의 파일시스템을 판별한다.
2. 각 파일시스템을 처리하는 프로세스를 호출하여 시스템 콜에 대응되는 처리를 한다.
3. 데이터의 읽기를 하는 경우 디바이스 드라이버에 처리를 의뢰한다.
4. 디바이스 드라이버가 데이터를 읽어들인다.

![파일시스템에 관계없이 통일된 인터페이스로 접근 가능함](/images/07-file-system/7-6.png) 

# 데이터와 메타데이터
파일시스템에는 데이터(data)와 메타데이터(metadata)라는 두 종류의 데이터가 있다.
* 데이터: 사용자가 작성한 문서나 사진, 동영상 프로그램 등의 내용
* 메타데이터: 파일의 보조 정보
  * 파일의 이름이
  * 저장 장치 내에 위치 사이즈
  * 종류: 데이터를 보관하는 일반 파일 or 디렉토리 or 다른 종류의 파일인지 판별하는 정보
  * 시간 정보: 작성한 시간, 최후에 접근한 시간, 최후에 내용이 변경된 시간
  * 권한 정보: 사용자 접근 권한

  >(참고) `df` 명령어로 얻은 파일시스템의 스토리지 사용량은 파일 시스템에 작성한 모든 파일의 합계 사이즈만이 아니라 **메타데이터의 사이즈도 더해지므로** 주의가 필요하다.

![파일시스템에 관계없이 통일된 인터페이스로 접근 가능함](/images/07-file-system/code1.png) 

# 용량 제한

파일시스템의 용량을 용도별로 사용할 수 있게 제한하는 **쿼터(quota)**라는 기능이 있다.

### 용량 제한(quota)이 필요한 이유
시스템을 여러 가지 용도로 사용하는 경우 특정 용도가 파일시스템의 용량을 무제한으로 사용할 수 있다면 다른 용도로 사용할 용량이 부족하게 되는 일이 발생한다.

특히 root 권한으로 동작하는 프로세스가 이용하는 시스템 관리 처리를 위한 용량이 부족하게 되면 **시스템 전체가 정상적으로 동작할 수 없게 된다**.

![파일시스템의 용량이 부족하게 되면 시스템이 정상적으로 동작하지 않음](/images/07-file-system/7-7.png) 

### Quota의 종류
quota에는 다음과 같은 종류가 있다.

* 사용자 쿼터: 파일의 소유자인 사용자 별로 용량을 제한한다. 예를 들어 특정 사용자 때문에 /home 용량이 부족한 사태를 방지한다. ext4와 XFS에서 사용 가능하다.
* 디렉토리 쿼터(혹은 프로젝트 쿼터): 특정 디렉토리 별로 용량을 제한하는 것이다. 예를 들어 프로젝트 멤버가 공유하는 디렉토리에 용량 제한을 걸어둔다. ext4와 XFS에서 사용 가능하다.
* 서브 볼륨 쿼터: 파일시스템 내의 서브 볼륨이라는 단위별 용량을 제한하는 것이다. 디렉토리 쿼터와 사용 방법이 유사하며, Btrfs에서 사용 가능하다.

![쿼터](/images/07-file-system/7-8.png) 

# 파일시스템이 깨진 경우
시스템을 운용하다보면 종종 파일시스템의 내용이 깨지는 경우가 발생한다. 전형적인 예로 파일시스템의 데이터를 스토리지에 쓰고 있는 도중에 시스템의 전원이 강제적으로 끊어졌을 때 같은 경우에 발생한다.

### 파일시스템이 깨진 상태
구체적으로 파일시스템이 깨진 경우란 어떤 상태인지 살펴보자. 아래의 예시는 **어떤 디렉토리를 다른 디렉토리 아래로 이동하는 경우이다**.

![디렉토리의 이동](/images/07-file-system/7-9.png) 

이것의 흐름을 그림으로 나타내면 [그림 7-10]과 같다.

![디렉토리의 이동 처리의 흐름](/images/07-file-system/7-10.png) 

이러한 일련의 처리는 **하나라도 누락되면 안되므로 '아토믹(atomic)'한 처리**라고 부른다.

저장 장치의 읽고 쓰기는 한 번에 한 가지씩만 처리되므로, 첫번째 쓰기(foo 파일의 데이터 업데이트)가 끝난 뒤에 두 번째 쓰기(root 데이터 업데이트)를 하기 전에 처리가 중단되면 [그림 7-11]과 같이 파일시스템이 깨진 상태가 된다.

![파일시스템이 깨짐](/images/07-file-system/7-11.png) 

일단 이런 일이 발생하면 빠르든 늦든 언제가는 파일시스템이 감지하게 된다. 마운트 시 발견할 경우에는 파일시스템의 마운트가 불가능하게 되고, 파일시스템에 접근 중에 발생한 경우에는 읽기 전용 모드로 다시 마운트(remount)하거나 최악의 경우 시스템에 패닉이 발생한다.

파일시스템이 깨지는 것을 방지하기 위한 기술은 여러 가지가 있다. 그 중에서 널리 사용되고 있는 것은 '저널링'과 'Copy on Write'라는 두 가지 방식이다. **ext4와 XFS는 저널링**으로, **Btrfs는 Copy on Write**로 각각 파일 시스템이 깨지는 것을 방지하고 있다.

### 저널링: ext4, XFS
저널링에서는 파일시스템 안에 저널 영역이라는 특수한 영역을 준비한다. 저널 영역은 사용자가 인식할 수 없는 메타데이터이다.

![저널링 방식에 의한 업데이트 처리](/images/07-file-system/7-12.png) 

파일시스템을 업데이트할 때에는 다음과 같은 순서로 진행된다.

1) 업데이트에 필요한 아토믹한 처리의 목록을 일단 저널 영역에 작성한다. 이 목록을 **저널로그**라고 부른다.
2) 저널 영역의 내용을 바탕으로 실제로 파일시스템의 내용을 업데이트한다.

#### 저널로그 작성 중 재부팅하는 경우
저널로그 업데이트 중에 강제로 전원을 끊어보면 [그림 7-12]과 같이 단순히 저널 영역의 데이터를 지워버릴 뿐, 실제 데이터는 처리하기 전과 같다.

![저널링을 이용해 깨짐을 방지함(1)](/images/07-file-system/7-13.png) 

#### 실제 데이터 작성 중 재부팅하는 경우
실제 데이터를 업데이트 하는 중에 강제로 전원이 끊어지는 경우가 발생한다면 [그림 7-14]와 같이 저널로그를 처음부터 다시 수행하면 파일시스템의 처리가 정상적으로 완료된다.

![저널링을 이용해 깨짐을 방지함(2)](/images/07-file-system/7-14.png) 

### Copy on Write: Btrfs
Copy on Write를 이용해 파일시스템이 깨지는 것을 방지하는 방식을 이해하기 위해서는 우선 파일 시스템에 데이터를 넣는 방법에 대해 이해해야 한다.

**ext4와 XFS 등의 예전부터 있는 파일시스템**은 일단 파일을 작성하면 그 파일의 배치 주소는 원칙적으로 바뀌지 않는다. 파일의 내용을 업데이트할 때마다 저장 장치 상의 같은 주소에 새로운 데이터를 써넣는다.

![Copy on Write 방식이 아닌 경우 파일의 업데이트](/images/07-file-system/7-15.png) 

이와 다르게 **Btrfs 등의 Copy on Write 유형의 파일시스템**은 일단 파일을 작성하더라고 업데이트할 때 다른 주소에 데이터를 쓰고 링크를 교체 연결한다. 

![Copy on Write 방식을 이용한 단순한 업데이트 처리](/images/07-file-system/7-16.png) 

[그림 7-16]은 단지 하나의 파일을 업데이트 하는 경우였지만 **아토믹으로 처리해야 할 여러 개의 처리를 실행할 경우에도 업데이트되는 데이터를 다른 주소에 전부 쓴 뒤에 링크를 고쳐쓰는 방식**으로 동작한다.

![Copy on Write 방식을 이용한 복잡한 업데이트 처리](/images/07-file-system/7-17.png) 

[그림 7-18]과 같이 강제 전원 단절이 발생하더라도 재부팅 후에 작성된 데이터를 삭제하면 문제 없다.

![Copy on Write 방식(3)](/images/07-file-system/7-18.png) 

### 파일시스템의 깨짐에 대한 대책
앞에서 설명한 기능을 사용하여 최근에는 파일시스템이 깨지는 경우가 줄어들고 있다. 그러나 파일시스템의 버그가 원인인 손상을 매우 적지만 여전히 발생할 수 있다.

일반적으로는 파일시스템을 **정기적으로 백업**하여 파일시스템이 깨진 경우에 마지막에 백업한 시점의 상태로 복원하는 것이 대책이다.

그러나 **정기적으로 백업이 불가능**하면 각 파일시스템에 준비된 복구용 명령어를 이용한다. 복구용 명령어는 파일시스템마다 다르다.

그러나 어느 파일시스템이라도 공통적으로 존재하는 것이 `fsck`라는 명령어(ext4라면 `fsck.ext4`, XFS라면 `xfs_repair`, Btrfs라면 `btrfs check`)이다. 이 명령어를 사용하면 파일시스템을 깨지지 않은 상태로 롤백할 수 있다. 그러나 **`fsck`는 다음과 같은 이유로 별로 추천하지 않는다**.

1. 깨지지 않았음을 확인하거나 복구하기 위해 파일시스템 전체를 조사하기 때문에 소요 시간이 파일시스템 사용량에 따라 증가한다.
2. 복구에 오랜 시간을 들여도 결국 실패하고 끝나는 경우도 많다.
3. 사용자가 원하는 상태로 복원한다는 보장이 없다. fsck는 어디까지나 데이터가 깨진 파일시스템을 무리해서라도 마운트 하려는 명령어에 지나지 않는다. **처리하면서 깨진 데이터는 내용과 관계없이 삭제한다**.

![fsck의 동작)](/images/07-file-system/7-19.png) 

# 파일의 종류
파일에는 사용자의 데이터를 보관하는 `일반 파일`과 파일을 보관하는 `디렉토리`가 있다. 리눅스는 그 외에도 `디바이스 파일`이라는 종류가 있다.

**리눅스는 스스로 동작하고 있는 하드웨어 상의 장치를 거의 모두 파일로서 표현하고 있다(네트워크는 어댑터는 예외로 장치에 대응되는 파일이 없다).** 그렇기 때문에 리눅스에서는 장치를 파일과 동등하게 `open()`과 `read()`, `write()` 등의 시스템 콜을 사용한다. 장치 고유의 복잡한 조작에는 `ioctl()` 시스템 콜을 사용한다. 참고로 디바이스 파일에 접근할 수 있는 것은 일반적으로 root만 가능하다.